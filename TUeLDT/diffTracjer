diff --git a/TUeLDT/TrackingLaneDAG_generic.cpp b/TUeLDT/TrackingLaneDAG_generic.cpp
index fd92bd9..bc60d30 100644
--- a/TUeLDT/TrackingLaneDAG_generic.cpp
+++ b/TUeLDT/TrackingLaneDAG_generic.cpp
@@ -1,4 +1,6 @@
-/*
+/******************************************************************************
+* NXP Confidential Proprietary
+* 
 * Copyright (c) 2017 NXP Semiconductor;
 * All Rights Reserved
 *
@@ -26,8 +28,21 @@ TrackingLaneDAG_generic::TrackingLaneDAG_generic(BufferingDAG_generic&& bufferin
   mStartBufferShift(false),
   mStartFiltering(false),
   mFiltersReady(false),
-  mMAX_PIXELS_ROI(mFrameGRAY_ROI.rows * mFrameGRAY_ROI.cols)
-
+  mMAX_PIXELS_ROI(mFrameGRAY_ROI.rows * mFrameGRAY_ROI.cols),
+  mLikelihood_LB(0),
+  mLikelihood_RB(0),
+  mLikelihood_NB(0),
+  mLikelihood_W(0),
+  mConditionalProb(0),
+  mCorrelationNB(0),
+  mPosterior(0),
+  mMaxPosterior(0),
+  mLOWER_LIMIT_BASE(0),
+  mLOWER_LIMIT_PURVIEW(0),
+  mUPPER_LIMIT_BASE(0),
+  mUPPER_LIMIT_PURVIEW(0),
+  mSTEP_BASE(0),
+  mSTEP_PURVIEW(0)
 {	
 	//Write Images to a video file
 	//mOutputVideo.open("TUeLaneTracker.avi", CV_FOURCC('M','P','4','V'), 30, mFrameRGB.size());
@@ -36,27 +51,42 @@ TrackingLaneDAG_generic::TrackingLaneDAG_generic(BufferingDAG_generic&& bufferin
 
 int TrackingLaneDAG_generic::init_DAG()
 {
-	mX_ICCS.convertTo(mX_ICCS_SCALED, CV_32S, SCALE_INTSEC );
+	const size_t& lCOUNT 	 = mLaneFilter->COUNT_BINS;
 
-        mHistBase      = cv::Mat::zeros(mLaneFilter->mNb_HISTOGRAM_BINS,  1 ,  CV_32S);
-        mHistPurview   = cv::Mat::zeros(mLaneFilter->mNb_HISTOGRAM_BINS,  1 ,  CV_32S);
+	mX_ICCS_SCALED	 	 =  SCALE_INTSEC*mX_ICCS;
+	mBASE_BINS_SCALED  	 =  SCALE_INTSEC*mLaneFilter->BASE_BINS;
+	mPURVIEW_BINS_SCALED	 =  SCALE_INTSEC*mLaneFilter->PURVIEW_BINS;
+
+	mLOWER_LIMIT_BASE	 =  mBASE_BINS_SCALED.at<int32_t>(0,0);
+	mLOWER_LIMIT_PURVIEW  	 =  mPURVIEW_BINS_SCALED.at<int32_t>(0,0);
+
+	mUPPER_LIMIT_BASE	 =  mBASE_BINS_SCALED.at<int32_t>(lCOUNT-1,0);
+	mUPPER_LIMIT_PURVIEW  	 =  mPURVIEW_BINS_SCALED.at<int32_t>(lCOUNT-1,0);
 
-  	return 0;
-}
 
+	//Assuming a constant step
+	mSTEP_BASE	 	 =  mBASE_BINS_SCALED.at<int32_t>(1,0)
+				   -mBASE_BINS_SCALED.at<int32_t>(0,0) ;
 
+	mSTEP_PURVIEW	 	 =  mPURVIEW_BINS_SCALED.at<int32_t>(1,0)
+				   -mPURVIEW_BINS_SCALED.at<int32_t>(0,0) ;
+
+        mHistBase      		 =  cv::Mat::zeros(lCOUNT,  1 ,  CV_32S);
+        mHistPurview   		 =  cv::Mat::zeros(lCOUNT,  1 ,  CV_32S);
+
+  	return 0;
+}
 
 
 void TrackingLaneDAG_generic::extractLanes()
 {
 
 	WriteLock  wrtLock(_mutex, std::defer_lock);
-
-	//Start Filtering
-	wrtLock.lock();
-	this->mStartFiltering = true;
-	wrtLock.unlock();
-	_sateChange.notify_one();
+	 //Start Filtering
+	 wrtLock.lock();
+	 this->mStartFiltering = true;
+	 wrtLock.unlock();
+	 _sateChange.notify_one();
 
 
 #ifdef PROFILER_ENABLED
@@ -93,15 +123,17 @@ LOG_INFO_(LDTLog::TIMING_PROFILE)<<endl
 #ifdef PROFILER_ENABLED
 mProfiler.start("COMPUTE_INTERSECTIONS");
 #endif	
+	
 	//Base Intersections
-	subtract(-mLaneFilter->OFFSET_V, -mY_ICCS, mIntBase, cv::noArray(), CV_32S);
+	subtract(-mLaneFilter->BASE_LINE_ICCS, -mY_ICCS, mIntBase, cv::noArray(), CV_32S);
 	divide(mIntBase, mGradTanFocussed, mIntBase, SCALE_INTSEC_TAN, CV_32S);
 	add(mIntBase, mX_ICCS_SCALED, mIntBase);
 	
 	//Purview Intersections
-	subtract(-mVpFilter->OFFSET_V, -mY_ICCS, mIntPurview, cv::noArray(), CV_32S);
+	subtract(-mLaneFilter->PURVIEW_LINE_ICCS, -mY_ICCS, mIntPurview, cv::noArray(), CV_32S);
 	divide(mIntPurview,mGradTanFocussed, mIntPurview, SCALE_INTSEC_TAN, CV_32S);
 	add(mIntPurview, mX_ICCS_SCALED, mIntPurview);
+
 	
 #ifdef PROFILER_ENABLED
 mProfiler.end();
@@ -122,15 +154,21 @@ LOG_INFO_(LDTLog::TIMING_PROFILE)<<endl
 #ifdef PROFILER_ENABLED
 mProfiler.start("MASK_INVALID_BIN_IDS");
 #endif
+     {
 	//Build Mask for Valid Intersections
-	bitwise_and(mProbMapFocussed > 0, mGradTanFocussed !=0,    mMask);
-	bitwise_and(mMask, mIntBase    > mLOWER_LIMIT_IntBase,     mMask);
-	bitwise_and(mMask, mIntPurview > mLOWER_LIMIT_IntPurview,  mMask);
-    	bitwise_and(mMask, mIntBase    < mUPPER_LIMIT_IntBase,     mMask);
-    	bitwise_and(mMask, mIntPurview < mUPPER_LIMIT_IntPurview,  mMask);
+	bitwise_and(mProbMapFocussed > 0, mGradTanFocussed !=0, mMask);
 
-        mHistBase      = cv::Mat::zeros(mLaneFilter->mNb_HISTOGRAM_BINS,  1 ,  CV_32S);
-        mHistPurview   = cv::Mat::zeros(mLaneFilter->mNb_HISTOGRAM_BINS,  1 ,  CV_32S);
+	bitwise_and(mMask, mIntBase    >  mLOWER_LIMIT_BASE,    mMask);
+	bitwise_and(mMask, mIntPurview >  mLOWER_LIMIT_PURVIEW, mMask);
+
+    	bitwise_and(mMask, mIntBase    <  mUPPER_LIMIT_BASE, 	mMask);
+    	bitwise_and(mMask, mIntPurview <  mUPPER_LIMIT_PURVIEW, mMask);
+
+
+	//^TODO: Put on the side thread
+        mHistBase      = cv::Mat::zeros(mLaneFilter->COUNT_BINS,  1 ,  CV_32S);
+        mHistPurview   = cv::Mat::zeros(mLaneFilter->COUNT_BINS,  1 ,  CV_32S);
+     }		
 
 #ifdef PROFILER_ENABLED
 mProfiler.end();
@@ -141,9 +179,7 @@ LOG_INFO_(LDTLog::TIMING_PROFILE)<<endl
 				<<  "Avg Time: " << mProfiler.getAvgTime("MASK_INVALID_BIN_IDS")<<endl
 				<<  "Min Time: " << mProfiler.getMinTime("MASK_INVALID_BIN_IDS")<<endl
 				<<"******************************"<<endl<<endl;	
-				#endif
-
-
+				#endif 
 
 
 
@@ -152,48 +188,39 @@ LOG_INFO_(LDTLog::TIMING_PROFILE)<<endl
 #ifdef PROFILER_ENABLED
 mProfiler.start("COMPUTE_HISTOGRAMS");
 #endif
-
 	//Weights of Intersections
 	multiply(mDepthTemplate, mProbMapFocussed, mIntWeights, 1, CV_32S);	
-
 	{
-	   int32_t* 	IN_basePTR 	    	= mIntBase.ptr<int32_t>(0);
-	   int32_t* 	IN_purviewPTR   	= mIntPurview.ptr<int32_t>(0);
-	   int32_t* 	IN_weightsPTR   	= mIntWeights.ptr<int32_t>(0);
-	   uint8_t* 	IN_maskPTR   		= mMask.ptr<uint8_t>(0);
+	   int32_t* 	lPtrIntBase 	    	= mIntBase.ptr<int32_t>(0);
+	   int32_t* 	lPtrIntPurview   	= mIntPurview.ptr<int32_t>(0);
+	   int32_t* 	lPtrWeights   		= mIntWeights.ptr<int32_t>(0);
+	   uint8_t* 	lPtrMask   		= mMask.ptr<uint8_t>(0);
 
-	   int32_t* 	HistBase_pixelPTR    	=  mHistBase.ptr<int32_t>(0);
-	   int32_t* 	HistPurview_pixelPTR 	=  mHistPurview.ptr<int32_t>(0);
+	   int32_t* 	lPtrHistBase    	=  mHistBase.ptr<int32_t>(0);
+	   int32_t* 	lPtrHistPurview 	=  mHistPurview.ptr<int32_t>(0);
 
 	   uint16_t   	lBaseBinIdx;
 	   uint16_t   	lPurviewBinIdx;
 	   int32_t    	lWeightBin;
 
-	   for (int i = 0; i < mMAX_PIXELS_ROI; i++,IN_basePTR++,IN_purviewPTR++, IN_weightsPTR++ , IN_maskPTR++)
+	   for (int i = 0; i < mMAX_PIXELS_ROI; i++,lPtrIntBase++,lPtrIntPurview++, lPtrWeights++ , lPtrMask++)
 	   {
-			
-		   if(!(*IN_maskPTR ==0) )
-		   {		
-			lBaseBinIdx=
-				(*IN_basePTR    - mSCALED_START_LANE_FILTER + (mSCALED_STEP_LANE_FILTER/2) )
-				/ mSCALED_STEP_LANE_FILTER;
-			
+	      if(!(*lPtrMask ==0) )
+	      {		
+		 lBaseBinIdx	= (*lPtrIntBase    - mLOWER_LIMIT_BASE    + (mSTEP_BASE/2))/mSTEP_BASE;
 
-			lPurviewBinIdx=
-				(*IN_purviewPTR -  mSCALED_START_VP_FILTER   + (mSCALED_STEP_VP_FILTER/2)  )
-				/ mSCALED_STEP_VP_FILTER ;
-			
-			lWeightBin = *IN_weightsPTR;
-			
-			
-			*(HistBase_pixelPTR 	+ lBaseBinIdx	)  	+= lWeightBin;
-			*(HistPurview_pixelPTR  + lPurviewBinIdx) 	+= lWeightBin;
-		   }	
+		 lPurviewBinIdx	= (*lPtrIntPurview - mLOWER_LIMIT_PURVIEW + (mSTEP_PURVIEW/2))/mSTEP_PURVIEW;
+		
+	         lWeightBin 	= *lPtrWeights;
+		
+	         *(lPtrHistBase     + lBaseBinIdx   )  	+= lWeightBin;
+	         *(lPtrHistPurview  + lPurviewBinIdx) 	+= lWeightBin;
+	      }	
 	   }
 		
 	}//Block Ends
 
-	
+
 #ifdef PROFILER_ENABLED
 mProfiler.end();
 LOG_INFO_(LDTLog::TIMING_PROFILE)<<endl
@@ -208,22 +235,17 @@ LOG_INFO_(LDTLog::TIMING_PROFILE)<<endl
 
 
 
-
-
-
 #ifdef PROFILER_ENABLED
 mProfiler.start("FILTERS_WAIT");
 #endif 				
-		
 	wrtLock.lock();
 	_sateChange.wait(wrtLock,[this]{return mFiltersReady;} );
 	mFiltersReady = false; //reset the flag for next loop.
 	this->mStartBufferShift = true;
 	wrtLock.unlock();
 	_sateChange.notify_one();
-
-				
- #ifdef PROFILER_ENABLED
+		
+#ifdef PROFILER_ENABLED
  mProfiler.end();
 LOG_INFO_(LDTLog::TIMING_PROFILE)<<endl
 				<<"******************************"<<endl
@@ -237,144 +259,128 @@ LOG_INFO_(LDTLog::TIMING_PROFILE)<<endl
 
 
 
+#ifdef PROFILER_ENABLED
+mProfiler.start("NORMALIZE_HISTOGRAM");
+#endif
+	{   
+   	    int64_t lSUM = 0;
+
+	    //Normalising Base Histogram
+	    lSUM = sum(mHistBase)[0];
+	    mHistBase.convertTo(mHistBase, CV_64F, SCALE_FILTER);
+	    mHistBase.convertTo(mHistBase, CV_32S, 1.0/lSUM );	 
+
+	    //Normalising Purview Histogram
+	    lSUM = sum(mHistPurview)[0];
+	    mHistPurview.convertTo(mHistPurview, CV_64F, SCALE_FILTER);
+	    mHistPurview.convertTo(mHistPurview, CV_32S, 1.0/lSUM );
+	}
+
+	
+
+
+#ifdef PROFILER_ENABLED
+ mProfiler.end();
+LOG_INFO_(LDTLog::TIMING_PROFILE)<<endl
+				<<"******************************"<<endl
+				<<  "Normalising Hitograms." <<endl
+				<<  "Max Time: " << mProfiler.getMaxTime("NORMALIZE_HISTOGRAM")<<endl
+				<<  "Avg Time: " << mProfiler.getAvgTime("NORMALIZE_HISTOGRAM")<<endl
+				<<  "Min Time: " << mProfiler.getMinTime("NORMALIZE_HISTOGRAM")<<endl
+				<<"******************************"<<endl<<endl;	
+				#endif	
+
+
 
 
 
 #ifdef PROFILER_ENABLED
 mProfiler.start("HISTOGRAM_MATCHING");
 #endif
-
 	{
-   	    int64_t SUM;
+	    int32_t   	lBestModelIdx = -1;
+	    int32_t* 	lPtrHistBase  = nullptr; 
+	    cv::Mat    	lRange;
 
-	    //Normalising Base Histogram
-	    SUM = sum(mHistBase)[0];
-	    mHistBase.convertTo(mHistBase, CV_64F, SCALE_FILTER);
-	    mHistBase.convertTo(mHistBase, CV_32S, 1.0/SUM );
-	 
+	    mPosterior		= 0;
+	    mMaxPosterior  	= 0;
 
-	    //Normalising Purview Histogram
-	    SUM = sum(mHistPurview)[0];
-	    mHistPurview.convertTo(mHistPurview, CV_64F, SCALE_FILTER);
-	    mHistPurview.convertTo(mHistPurview, CV_32S, 1.0/SUM );
-		
-		
-	   int   BestModelIdx=-1;
-	   int   NegLaneCorrelation;
-	   float x;
-	   int   bestPosteriorProb  = 0;
-	   float conditionalProb;
-		
-	   int32_t* HistBasePTR    	=  mHistBase.ptr<int32_t>(0);
-	   vector<BaseHistogramModel>& Models= mLaneFilter->baseHistogramModels;
-	   cv::Mat    range;
+	    vector<BaseHistogramModel>& Models	= mLaneFilter->baseHistogramModels;
+	    lPtrHistBase			=  mHistBase.ptr<int32_t>(0);
 	
 	   for(size_t i=0; i< Models.size(); i++)
 	   {    
 			
-		int& LeftIdx    	= Models[i].binID_leftBoundary;
-		int& RightIdx		= Models[i].binID_rightBoundary;
+		int& lIdx_BL    	 = Models[i].binIdxBoundary_left;
+		int& lIdx_BR		 = Models[i].binIdxBoundary_right;
 
-		int& NegLeftIdx		= Models[i].binID_NegBoundaryLeft;
-		int& NegRightIdx    	= Models[i].binID_NegBoundaryRight;
+		int& lIdx_NBL	 	 = Models[i].binIdxNonBoundary_left;
+		int& lIdx_NBR    	 = Models[i].binIdxNonBoundary_right;
 
-		int& Nleft          	= Models[i].nbNonBoundaryBinsLeft;
-		int& Nright		= Models[i].nbNonBoundaryBinsRight;
+		int& lCount_NBL          = Models[i].nonBoundaryBinsCount_left;
+		int& lCount_NBR		 = Models[i].nonBoundaryBinsCount_right;
 
-		
-
-		mLikelihoodLeftBoundary =  round(HistBasePTR[LeftIdx-1]*0.25
-						+HistBasePTR[LeftIdx]
-						+HistBasePTR[LeftIdx+1]*0.25);
+		mLikelihood_LB  	=  lPtrHistBase[lIdx_BL-1]*0.25
+					   +lPtrHistBase[lIdx_BL]
+					   +lPtrHistBase[lIdx_BL+1]*0.25;
 										 
-		mLikelihoodRightBoundary = round( HistBasePTR[RightIdx-1]*0.25
-						+HistBasePTR[RightIdx]
-						+HistBasePTR[RightIdx+1]*0.25);
+		mLikelihood_RB 		=  lPtrHistBase[lIdx_BR-1]*0.25
+					   +lPtrHistBase[lIdx_BR]
+					   +lPtrHistBase[lIdx_BR+1]*0.25;
 	
-		conditionalProb  =  (mLikelihoodLeftBoundary*mLikelihoodRightBoundary)/(float)SCALE_FILTER;
+		mConditionalProb  	=  (mLikelihood_LB *mLikelihood_RB)/(float)SCALE_FILTER;
 
 
-//TODO:	Put on the side thread.(start)
-		NegLaneCorrelation=0;
-		range = mHistBase(cv::Range(NegLeftIdx,  NegLeftIdx  +  Nleft), cv::Range::all());
-		NegLaneCorrelation +=sum(range)[0];
-		
-	    	range = mHistBase(cv::Range(NegRightIdx, NegRightIdx + Nright), cv::Range::all());
-		NegLaneCorrelation +=sum(range)[0];
+		//TODO:start=> Put this block on the side thread
+		mCorrelationNB	= 0;
+		lRange = mHistBase(cv::Range(lIdx_NBL,  lIdx_NBL  +  lCount_NBL), cv::Range::all());
+		mCorrelationNB +=sum(lRange)[0];
 		
-		x= (float)NegLaneCorrelation / SCALE_FILTER ;
+	    	lRange = mHistBase(cv::Range(lIdx_NBR, lIdx_NBR + lCount_NBR), cv::Range::all());
+		mCorrelationNB +=sum(lRange)[0];
 		
-		mLikelihoodNegBoundary = mLaneMembership.NEG_BOUNDARY_NORMA 
-				       * exp ( - pow(x,2) / mLaneMembership.NEG_BOUNDARY_NOMIN );
-//(end)
-			
+		float x= (float)mCorrelationNB / SCALE_FILTER ; 
+		mLikelihood_NB = mLaneMembership.NEG_BOUNDARY_NORMA*exp(-pow(x,2)/mLaneMembership.NEG_BOUNDARY_NOMIN );
+		//(end)
 
-		conditionalProb  = (conditionalProb * mLikelihoodNegBoundary); 
+		mConditionalProb  = (mConditionalProb * mLikelihood_NB); 
 	
+		size_t lRowIdx = Models[i].rowIdxFilter; 
+		size_t lColIdx = Models[i].colIdxFilter; 
 	    
-		mPosteriorProbBase = round(conditionalProb*
-		mTransitLaneFilter.at<int32_t>(Models[i].leftOffsetIdx, Models[i].rightOffsetIdx) );
-		
-		mLaneFilter->filter.at<int32_t>(Models[i].leftOffsetIdx, Models[i].rightOffsetIdx)
-		= mPosteriorProbBase;
+		mPosterior = round( mConditionalProb*mTransitLaneFilter.at<int32_t>(lRowIdx, lColIdx) );
+		mLaneFilter->filter.at<int32_t>(lRowIdx, lColIdx) = mPosterior;
 
-		if(mPosteriorProbBase > bestPosteriorProb)
+		//Keep track of the best Model
+		if(mPosterior > mMaxPosterior)
 		{
-		   bestPosteriorProb=mPosteriorProbBase;
-				
-		   BestModelIdx =i;
-		   mLaneModel.confidenceLeft  = mLikelihoodLeftBoundary;
-		   mLaneModel.confidenceRight = mLikelihoodRightBoundary;
+		   mMaxPosterior = mPosterior; 
+		   lBestModelIdx = i;
 		}
-
 				
-	   } 
+	   } //Loop over all BaseHistogram Models
 		
-	   if (bestPosteriorProb == 0)
-	   return;
-		  
-	   mLaneModel.leftOffset 	= Models[BestModelIdx].leftOffset;
-	   mLaneModel.rightOffset	= Models[BestModelIdx].rightOffset;
-	   mLaneModel.centerLane    	= round((mLaneModel.leftOffset + mLaneModel.rightOffset)/2.0);
-		
-	   mLaneModel.laneWidth     	= Models[BestModelIdx].width_cm;
-	 
-	   mLaneModel.confidenceLeft  	= round(100* mLaneModel.confidenceLeft/(float)SCALE_FILTER);
-	   mLaneModel.confidenceRight  	= round(100* mLaneModel.confidenceRight/(float)SCALE_FILTER);
+	   if (mMaxPosterior == 0)
+	      return;
+	   else
+	      mBaseHistModel = Models[lBestModelIdx];
 
-		cout <<"Index : "<<BestModelIdx;
-		cout<< "Filter: "<<mPosteriorProbBase;
+	cout<<endl;
+	cout<<"selected Index: "<<lBestModelIdx<<endl;
+        cout<<"Filter Value  : "<< mPosterior <<endl;
 		
 	}//Scope End
 
 
-	   {
-	     
-	     cv::Mat lIntBase, lIntPurview, lIntWeights, lMask,  lHistBase, lHistPurview;
-	     cv::FileStorage file("/home/s32v/compare/Mat_new", cv::FileStorage::READ);
-	     file["mIntBase"]>> lIntBase;
-	     file["mIntPurview"]>> lIntPurview;
-	     file["mIntWeights"]>> lIntWeights;
-	     file["mMask"]>> lMask;
-	     file["mHistBase"]>>lHistBase;
-	     file["mHistPurview"]>>lHistPurview;
-
-	     // lHistBase.convertTo(lIntBase, CV_32S);
-	     int d  = cv::norm(mIntBase, lIntBase, cv::NORM_INF);
-		 d += cv::norm(mIntPurview, lIntPurview, cv::NORM_INF);
-		 d += cv::norm(mIntWeights, lIntWeights, cv::NORM_INF);
-		 d += cv::norm(mMask, lMask, cv::NORM_INF);
-		 d += cv::norm(mHistBase,    lHistBase,    cv::NORM_INF);
-		 d += cv::norm(mHistPurview, lHistPurview, cv::NORM_INF);
-
-	      cout<<"dist: " << d <<endl;
-	     
-	     //cout<<"size of Histogram Base:" << lHistBase.size()<<"	vs	"<< mHistBase.size()<<endl;
-	   }
-
-	  exit(0);
-
-
+     	{
+ 	  cv::FileStorage file("/home/s32v/compare/Mat_new", cv::FileStorage::WRITE);
+	  file<<"mIntBase"<<mIntBase;
+          file<<"mIntPurview"<<mIntPurview;
+          file<<"mIntWeights"<<mIntWeights;
+          file<<"mMask"<<mMask;
+	  file<<"mHistBase"<<mHistBase;
+  	  file<<"mHistPurview"<<mHistPurview;
+     	}
 		
 #ifdef PROFILER_ENABLED
 mProfiler.end();
@@ -393,126 +399,101 @@ LOG_INFO_(LDTLog::TIMING_PROFILE)<<endl
 #ifdef PROFILER_ENABLED
 mProfiler.start("VP_HISTOGRAM_MATCHING");
 #endif
-	
-	{	
-	   int   		bestPosteriorProb  = 0;
-	   int32_t* 		HistPurviewPTR     =  mHistPurview.ptr<int32_t>(0);
+	{
+	   const int& 	lBaseLB  		= mBaseHistModel.boundary_left;	
+	   const int& 	lBaseRB 		= mBaseHistModel.boundary_right;
 
+	   const int& 	lBaseLine		= mLaneFilter->BASE_LINE_ICCS;
+	   const int& 	lPurviewLine		= mLaneFilter->PURVIEW_LINE_ICCS;
 	
-	   const float left_VP  = -mLaneModel.leftOffset ;												
-	
-	   const float right_VP  = mLaneModel.rightOffset ;
-				
-		
-	   const int    FRAME_CENTER_V		= mCAMERA.FRAME_CENTER(0);
-	   const float  PIXEL_TO_CM     	= 1.0/mCAMERA.CM_TO_PIXEL;
-
-	   const int    VP_FILTER_OFFSET 	= mVpFilter->OFFSET_V;
-	   const int    VP_HIST_STEP	 	= mVpFilter->STEP;
-	   const int    VP_HIST_START	 	= mVpFilter->HISTOGRAM_BINS(0);
-	   const int    VP_HIST_SIZE	 	= mVpFilter->HISTOGRAM_BINS.size();
-	   const int    VP_HIST_END	 	= mVpFilter->HISTOGRAM_BINS(VP_HIST_SIZE-1);
-	   const float  VP_HIST_RATIO  	 	= mVpFilter->mVP_LANE_RATIO;
-	   const float  WIDTH_FACTOR   	 	= PIXEL_TO_CM* 1.0/VP_HIST_RATIO;
-		
+	   int32_t	lIntSecLeft, lIntSecRight, lWidth_cm;
 
-	   float  IntSecLeft, IntSecRight; 
-	   int    LeftIdx, MidIdx, RightIdx;
+	   size_t  	lIdx_BL, lIdx_Mid, lIdx_BR, lIdx_NBL, lIdx_NBR, lCount_NBL, lCount_NBR;
 
-	   int   NegLeftIdx, NegRightIdx;
-	   int   NbNegLaneLeft, NbNegLaneRight, NegLaneCorrelation;
-	   float x, conditionalProb;
-	
-	   cv::Mat   range;
-	
-	   float  width_cm;
-	
-	   // Store Previous values of VP 
+	   cv::Mat   	lRange;
+
+	   mPosterior	 = 0;	
+	   mMaxPosterior = 0;
+
+	   // Save current values of VP 
 	   mVanishPt.V_prev = mVanishPt.V;
 	   mVanishPt.H_prev = mVanishPt.H;
-		
-	   for(int v=0; v < mVpFilter->mNb_VP_BINS_V;v++)
-	   {	for(int h=0; h < mVpFilter->mNb_VP_BINS_H; h++)
+	
+	   int32_t* 	lPtrHistPurview  = mHistPurview.ptr<int32_t>(0);
+
+	   for(int v=0; v < mVpFilter->COUNT_BINS_V;v++)
+	   {	for(int h=0; h < mVpFilter->COUNT_BINS_H; h++)
 		{
-		   const	int&  binV = mVpFilter->VP_BINS_V(v);
-		   const 	int&  binH = mVpFilter->VP_BINS_H(h);
+		   const int&  binV = mVpFilter->BINS_V(v);
+		   const int&  binH = mVpFilter->BINS_H(h);
 		
-		   IntSecLeft = ((binH - left_VP)/(float)(binV - FRAME_CENTER_V))
-					 *(VP_FILTER_OFFSET - binV) +binH;
+		   lIntSecLeft  = SCALE_INTSEC*( ((binH - lBaseLB)/(float)(binV - lBaseLine))*(lPurviewLine - binV) +binH );
+		   lIntSecRight = SCALE_INTSEC*( ((binH - lBaseRB)/(float)(binV - lBaseLine))*(lPurviewLine - binV) +binH );
 
+		   lIdx_BL 	= ( lIntSecLeft  - mLOWER_LIMIT_PURVIEW + (mSTEP_PURVIEW/2))/mSTEP_PURVIEW;
+		   lIdx_BR 	= ( lIntSecRight - mLOWER_LIMIT_PURVIEW + (mSTEP_PURVIEW/2))/mSTEP_PURVIEW;
 
-		   IntSecRight 	= ((binH - right_VP)/(float)(binV - FRAME_CENTER_V))
-				  *(VP_FILTER_OFFSET - binV) +binH;
+		   lIdx_Mid  	= round((lIdx_BL+ lIdx_BR)/2.0 );
 
-		   IntSecLeft 	= VP_HIST_STEP * round(IntSecLeft/VP_HIST_STEP);
+		   //^TODO:start=> Make non-boundary region dependent on the binwidth
+		   lIdx_NBL   	= lIdx_BL   + 2;
+		   lIdx_NBR 	= lIdx_Mid  + 4;	
+		   lCount_NBL   = (lIdx_Mid - 3) - (lIdx_BL  + 2) ;        
+		   lCount_NBR   = (lIdx_BR  - 2) - (lIdx_Mid + 3) ;
+		   //(TODO:end)
 
-	           LeftIdx 	= (IntSecLeft  - VP_HIST_START + (VP_HIST_STEP/2))/VP_HIST_STEP;
-	           RightIdx 	= (IntSecRight - VP_HIST_START + (VP_HIST_STEP/2))/VP_HIST_STEP;
-		
-		   MidIdx  	= round( ( LeftIdx+ RightIdx ) /2.0);
-		
-		   NegLeftIdx  	   = LeftIdx+2;
-		   NegRightIdx     = MidIdx+4;
-		
-		   NbNegLaneLeft   = (MidIdx-3) - (LeftIdx+ 2) ;        
-		   NbNegLaneRight  = (RightIdx-2) - (MidIdx+3);
-		
-		   width_cm= (IntSecRight -IntSecLeft) * WIDTH_FACTOR;
+		   lWidth_cm= mLaneFilter->BINS_cm(lIdx_BR) - mLaneFilter->BINS_cm(lIdx_BL);
 					   
-		   if (LeftIdx > 0 && RightIdx < VP_HIST_SIZE-2)
-		   {	
-			
-		      // VP Probability over Lane Width at Offseted-VP 
-		      mLikelihoodVP_Width = mLaneMembership.WIDTH_DIFF_NORMA 
-		       * exp( - pow(mLaneModel.laneWidth - width_cm, 2) / mLaneMembership.WIDTH_DIFF_NOMIN );
-				
-				
-		      // VP Probability over Left LaneBoundary
-		      mLikelihoodVP_LBoundary =  round(HistPurviewPTR[LeftIdx-1]*0.25
-					      + HistPurviewPTR[LeftIdx]
-				  	      + HistPurviewPTR[LeftIdx+1]*0.25);
+		   if (lIdx_BL > 0 && lIdx_BR < mLaneFilter->COUNT_BINS -2 )
+		   {			
+		      // VP Probability over lane width difference between base and purview line
+		      mLikelihood_W  	= mLaneMembership.WIDTH_DIFF_NORMA;
+		      mLikelihood_W    *= exp(-pow(mBaseHistModel.width_cm - lWidth_cm, 2) / mLaneMembership.WIDTH_DIFF_NOMIN );
+		
+		      // VP Probability over left lane boundary
+		      mLikelihood_LB 	=  round(lPtrHistPurview[lIdx_BL-1]*0.25
+					      + lPtrHistPurview[lIdx_BL]
+				  	      + lPtrHistPurview[lIdx_BL+1]*0.25);
 												  
 		      // VP Probability over Right LaneBoundary 				 
-		      mLikelihoodVP_RBoundary = round(HistPurviewPTR[RightIdx-1]*0.25
-					      + HistPurviewPTR[RightIdx]
-					      + HistPurviewPTR[RightIdx+1]*0.25);
+		      mLikelihood_RB 	= round(lPtrHistPurview[lIdx_BR-1]*0.25
+					      + lPtrHistPurview[lIdx_BR]
+					      + lPtrHistPurview[lIdx_BR+1]*0.25);
 					
-		      conditionalProb  =  (mLikelihoodVP_LBoundary*mLikelihoodVP_RBoundary) /(float)SCALE_FILTER;	
+		      mConditionalProb  =  (mLikelihood_LB*mLikelihood_RB) /(float)SCALE_FILTER;
 		
-		      //VP Probability over Negative(NO) Boundary
-		      NegLaneCorrelation=0;
-		      range = mHistPurview(cv::Range(NegLeftIdx,  NegLeftIdx  +  NbNegLaneLeft), cv::Range::all());
-		      NegLaneCorrelation +=sum(range)[0];
+		      //VP Probability over Non-Boundary Region
+		      mCorrelationNB = 0;
+
+		      lRange 		= mHistPurview(cv::Range(lIdx_NBL, lIdx_NBL + lCount_NBL), cv::Range::all());
+		      mCorrelationNB   +=sum(lRange)[0];
 			
-		      range = mHistPurview(cv::Range(NegRightIdx, NegRightIdx + NbNegLaneRight), cv::Range::all());
-		      NegLaneCorrelation +=sum(range)[0];
+		      lRange 		= mHistPurview(cv::Range(lIdx_NBR, lIdx_NBR + lCount_NBR), cv::Range::all());
+		      mCorrelationNB   +=sum(lRange)[0];
 		
-		      x= (float)NegLaneCorrelation / SCALE_FILTER ;
-		      mLikelihoodVP_NegBoundary = mLaneMembership.NEG_BOUNDARY_NORMA 
-		       *exp (-pow(x,2)/mLaneMembership.NEG_BOUNDARY_NOMIN);
+		      mLikelihood_NB	= mLaneMembership.NEG_BOUNDARY_NORMA;
+		      mLikelihood_NB   *= exp(-pow( mCorrelationNB/(float)SCALE_FILTER , 2)/mLaneMembership.NEG_BOUNDARY_NOMIN);
 											 				 
 		      //Conditional Probability			 
-		      conditionalProb  =   conditionalProb
-					* mLikelihoodVP_NegBoundary
-					* mLikelihoodVP_Width;
+		      mConditionalProb  =   mConditionalProb* mLikelihood_NB * mLikelihood_W;
 					
-		      mPosteriorProbVP = round(conditionalProb * mTransitVpFilter.at<int32_t>(v ,h));
+		      mPosterior 	= round(mConditionalProb * mTransitVpFilter.at<int32_t>(v ,h));
 			
-		      mVpFilter->filter.at<int32_t>(v, h) = mPosteriorProbVP;
+		      mVpFilter->filter.at<int32_t>(v, h) = mPosterior;
 
-		      if(mPosteriorProbVP > bestPosteriorProb)
+		      if(mPosterior > mMaxPosterior)
 		      {
-			   bestPosteriorProb=mPosteriorProbVP;
-			   mVanishPt.V =  binV;
-			   mVanishPt.H =  binH;
-		      }
+			mMaxPosterior	= mPosterior;
+			mVanishPt.V 	= binV;
+			mVanishPt.H 	= binH;
+		      }//end, if posterior is greater than existing Max
 
-		   }
+		    } //end, if Intersections are not in the BIN-Range 
 					
-		}			
-	     }
+		 }//for-end			
+	     }//for-end
 		
-	     if (bestPosteriorProb == 0)
+	     if (mMaxPosterior == 0)
 	     {
 		mVanishPt.V = mVanishPt.V_prev;
 		mVanishPt.H = mVanishPt.H_prev;
@@ -536,6 +517,26 @@ LOG_INFO_(LDTLog::TIMING_PROFILE) <<endl
 
 
 
+#ifdef PROFILER_ENABLED
+mProfiler.start("ASSIGN_LANE_MODEL");
+#endif
+	mLaneModel.setModel(mBaseHistModel.boundary_left,
+			    mBaseHistModel.boundary_left_cm,
+			    mBaseHistModel.boundary_right,
+			    mBaseHistModel.boundary_right_cm,
+			    mVanishPt);
+
+#ifdef PROFILER_ENABLED
+mProfiler.end();
+LOG_INFO_(LDTLog::TIMING_PROFILE) <<endl
+				<<"******************************"<<endl
+				<<  "Histogram Matching MAP Estimate VanishingPt."<<endl
+				<<  "Max Time: " << mProfiler.getMaxTime("ASSIGN_LANE_MODEL")<<endl
+				<<  "Avg Time: " << mProfiler.getAvgTime("ASSIGN_LANE_MODEL")<<endl
+				<<  "Min Time: " << mProfiler.getMinTime("ASSIGN_LANE_MODEL")<<endl
+		  		<<"******************************"<<endl<<endl;	
+				#endif
+
 
 
 #ifdef PROFILER_ENABLED
@@ -544,128 +545,10 @@ mProfiler.start("DISPLAY");
 
 	#ifdef DISPLAY_GRAPHICS
 	{
-	  using namespace cv;
-
-	   const float lRatioLookAhead = 0.35;
-
-	   //Transform VP to Image Coordianate System
-	   int VP_V =  mVanishPt.V + mCAMERA.FRAME_CENTER(0);
-	   int VP_H =  mVanishPt.H + mCAMERA.FRAME_CENTER(1);	
-
-	   //Lane Bundaries
-	   Point  Start_leftLaneInner( mCAMERA.FRAME_CENTER(1) 	-  
-		((int)( mLaneModel.leftOffset)/mLaneFilter->STEP)*mLaneFilter->STEP,  mCAMERA.RES_VH(0) );
-
-	   Point  Start_rightLaneInner( mCAMERA.FRAME_CENTER(1) +  
-		((int)( mLaneModel.rightOffset)/mLaneFilter->STEP)*mLaneFilter->STEP,  mCAMERA.RES_VH(0) );
-	
-	   Point  StartMidLane( ((int)((Start_leftLaneInner.x + Start_rightLaneInner.x)/2.0)/ mLaneFilter->STEP)* 
-		  mLaneFilter->STEP,  mCAMERA.RES_VH(0) );
- 
-	   float slopeLeft =  (float)( VP_V-mCAMERA.RES_VH(0) ) / (VP_H- Start_leftLaneInner.x);
-	   float slopeRight = (float)( VP_V-mCAMERA.RES_VH(0) ) / (VP_H- Start_rightLaneInner.x);
-	
-
-	   Point End_leftLaneInner 	= Start_leftLaneInner;
-	   End_leftLaneInner.x 		+= -round((mCAMERA.RES_VH(0)*lRatioLookAhead) / slopeLeft);
-	   End_leftLaneInner.y 		+= -round( (mCAMERA.RES_VH(0)*lRatioLookAhead));
-	
-	   Point End_rightLaneInner 	= Start_rightLaneInner;
-	   End_rightLaneInner.x 	+= -round ((mCAMERA.RES_VH(0)*lRatioLookAhead) / slopeRight);
-	   End_rightLaneInner.y 	+= -round ((mCAMERA.RES_VH(0)*lRatioLookAhead));
-
-
-	   // Draw Left Boundary Line
-	   line(mFrameRGB,
-		 Start_leftLaneInner,
-		 End_leftLaneInner,
-		 CvScalar(0,255,0),
-		 3
-	   	);
-
-	   //Draw Right Boundary Line	
-	   line(mFrameRGB,
-		 Start_rightLaneInner,
-		 End_rightLaneInner,
-		 CvScalar(0,255,0),
-		 3
-	   	);
-	   
-	   //Draw Middle Line
-	   line(mFrameRGB,
-	     StartMidLane,
-	     (End_rightLaneInner + End_leftLaneInner)/2.0,
-	     CvScalar(255,0,0),
-	     2
-	    );
-
-
-	   //Draw Purview Line
-	   line(mFrameRGB,
-	     cvPoint(0, mCAMERA.FRAME_CENTER(0) +  mVpFilter->OFFSET_V),
-	     cvPoint(mCAMERA.RES_VH(1), mCAMERA.FRAME_CENTER(0) + mVpFilter->OFFSET_V),
-	     CvScalar(0,0,0),
-	     1
-	    );
-	
- 
-	  // Highlight ROI 
-	   Rect lROI;
-	   lROI = Rect(0, mCAMERA.RES_VH(0) - mSpan, mCAMERA.RES_VH(1), mSpan);
-	   cv::Mat lYellow(mSpan, mCAMERA.RES_VH(1), CV_8UC3, Scalar(0,125,125));
-
-    	   cv::Mat lFrameRGB_mSPAN = mFrameRGB(lROI);
-	   cv::addWeighted(lYellow, 0.4, lFrameRGB_mSPAN, 0.6, 0, lFrameRGB_mSPAN);
-	
-
-	
-	   // Draw Histogram-Bins at the Base
-	   for (int i=0; i< mLaneFilter->HISTOGRAM_BINS.size(); i++)
-	   {
-		int x = mCAMERA.FRAME_CENTER(1)+ mLaneFilter->HISTOGRAM_BINS(i); 
-		if(x !=  StartMidLane.x)
-		line(mFrameRGB, cvPoint(x,mCAMERA.RES_VH(0)), cvPoint(x,mCAMERA.RES_VH(0) -30), cvScalar(0,0,0), 1);
-		else
-		line(mFrameRGB, cvPoint(x,mCAMERA.RES_VH(0)), cvPoint(x,mCAMERA.RES_VH(0) -40), cvScalar(0,0,255), 2);
-	   }
-
-
-
-	   // Draw Histogram-Bins at the Purview
-	   for (int i=0; i< mVpFilter->HISTOGRAM_BINS.size(); i++)
-	   {
-
-		int x = mCAMERA.FRAME_CENTER(1)+ mVpFilter->HISTOGRAM_BINS(i);
-		//if(x !=  StartMidLane.x)
-		line(mFrameRGB, cvPoint(x,mCAMERA.FRAME_CENTER(0) + mVpFilter->OFFSET_V), 
-				cvPoint(x,mCAMERA.FRAME_CENTER(0) + mVpFilter->OFFSET_V-30), cvScalar(0,0,0), 1);
-	   }
-
-
-	   #ifdef DISPLAY_GRAPHICS_DCU
-	   	mDCU.PutFrame(mFrameRGB.data);
-	   #else  
-
-	   imshow( "Display window", mFrameRGB);
-	   
-	   if ( (char)32 == (char) waitKey(10) )
-	   {
-		cout << "Lane Histogram Bins :		"<< mLaneFilter->HISTOGRAM_BINS.transpose() <<endl << endl;
-
-		cout << "VanishingPt Histogram Bins : 	"<< mVpFilter->HISTOGRAM_BINS.transpose() <<endl << endl;
-
-		while ((char)32 != (char)waitKey(1));
-	   }
-
-	   #endif
-
-
-
 	   //write the processed frame to the video
 	   //mOutputVideo<<mFrameRGB;
 	}
-	#endif // Display Graphics
-		
+	#endif // Display Graphics	
 								
 #ifdef PROFILER_ENABLED
 mProfiler.end();
@@ -677,8 +560,6 @@ LOG_INFO_(LDTLog::TIMING_PROFILE) <<endl
 				<<  "Min Time: " << mProfiler.getMinTime("DISPLAY")<<endl
 		  		<<"******************************"<<endl<<endl;	
 		 		#endif
-
-
 }//extractLanes
 
 
@@ -692,7 +573,6 @@ void TrackingLaneDAG_generic::extractControllerInputs()
 
 void TrackingLaneDAG_generic::runAuxillaryTasks()
 {
-		
 	int  lRowIndex;
 	cv::Rect lROI;
 	WriteLock  wrtLock(_mutex, std::defer_lock);
@@ -702,19 +582,18 @@ void TrackingLaneDAG_generic::runAuxillaryTasks()
 
 // MODE: A + C 
 	{
-
 		wrtLock.unlock();
 		 // Extract Depth Template
-		 lRowIndex = mCAMERA.RES_VH(0)- mSpan; 
-		 lROI = cv::Rect(0,lRowIndex,mCAMERA.RES_VH(1), mSpan);
+		 lRowIndex = mCAMERA.RES_VH(0)- mSPAN; 
+		 lROI = cv::Rect(0,lRowIndex,mCAMERA.RES_VH(1), mSPAN);
 
 		wrtLock.lock();
 		 mDEPTH_MAP_ROOT(lROI).copyTo(mDepthTemplate);
 		wrtLock.unlock();
 
 		 // Extract Focus Template
-		 lRowIndex = mVP_Range_V - mVanishPt.V;
-		 lROI = cv::Rect(0, lRowIndex, mCAMERA.RES_VH(1), mSpan);
+		 lRowIndex = mVP_RANGE_V - mVanishPt.V;
+		 lROI = cv::Rect(0, lRowIndex, mCAMERA.RES_VH(1), mSPAN);
 		
 		wrtLock.lock();
 		 mFOCUS_MASK_ROOT(lROI).copyTo(mFocusTemplate);	
@@ -737,15 +616,15 @@ void TrackingLaneDAG_generic::runAuxillaryTasks()
 // MODE: A ONLY 
 	{
 		wrtLock.unlock();
-		 lRowIndex = mCAMERA.RES_VH(0)- mSpan; 
-		 lROI = cv::Rect(0,lRowIndex,mCAMERA.RES_VH(1), mSpan);
+		 lRowIndex = mCAMERA.RES_VH(0)- mSPAN; 
+		 lROI = cv::Rect(0,lRowIndex,mCAMERA.RES_VH(1), mSPAN);
 		
 		wrtLock.lock();
 		 mDEPTH_MAP_ROOT(lROI).copyTo(mDepthTemplate);
 		wrtLock.unlock();
 
-		lRowIndex = mVP_Range_V-mVanishPt.V;
-		lROI = cv::Rect(0, lRowIndex, mCAMERA.RES_VH(1), mSpan);
+		lRowIndex = mVP_RANGE_V-mVanishPt.V;
+		lROI = cv::Rect(0, lRowIndex, mCAMERA.RES_VH(1), mSPAN);
 
 
 		wrtLock.lock();
@@ -762,16 +641,16 @@ void TrackingLaneDAG_generic::runAuxillaryTasks()
 	wrtLock.lock();
 	_sateChange.wait(wrtLock,[this]{return mStartFiltering;} );
 
-	int64_t SUM;
+	int64_t lSUM;
 	
 	//Predict Lane States
 	mLaneFilter->filter.convertTo(mLaneFilter->filter, CV_64F);
 	boxFilter(mLaneFilter->filter, mTransitLaneFilter, -1, cv::Size(11,11), cv::Point(-1,-1), false, cv::BORDER_REPLICATE );
     	mLaneFilter->filter.convertTo(mLaneFilter->filter, CV_32S);
 
-	SUM = sum(mTransitLaneFilter)[0];
+	lSUM = sum(mTransitLaneFilter)[0];
 	mTransitLaneFilter= mTransitLaneFilter*SCALE_FILTER;
-	mTransitLaneFilter.convertTo(mTransitLaneFilter, CV_32S, 1.0/SUM);
+	mTransitLaneFilter.convertTo(mTransitLaneFilter, CV_32S, 1.0/lSUM);
 	mTransitLaneFilter = 	mTransitLaneFilter + 0.1*mLaneFilter->prior;
 
 
@@ -780,9 +659,9 @@ void TrackingLaneDAG_generic::runAuxillaryTasks()
 	boxFilter(mVpFilter->filter, mTransitVpFilter, -1, cv::Size(3,3), cv::Point(-1,-1), false, cv::BORDER_REPLICATE );
     	mVpFilter->filter.convertTo(mVpFilter->filter, CV_32S);
 	
-	SUM = sum(mTransitVpFilter)[0];
+	lSUM = sum(mTransitVpFilter)[0];
 	mTransitVpFilter= mTransitVpFilter*SCALE_FILTER;
-	mTransitVpFilter.convertTo(mTransitVpFilter, CV_32S, 1.0/SUM);	
+	mTransitVpFilter.convertTo(mTransitVpFilter, CV_32S, 1.0/lSUM);	
 	mTransitVpFilter = mTransitVpFilter + 0.1*mVpFilter->prior;
 			
 
@@ -792,9 +671,6 @@ void TrackingLaneDAG_generic::runAuxillaryTasks()
 	wrtLock.unlock();
 	_sateChange.notify_one();
 
-
-
-
 // MODE: C  
 
 	wrtLock.lock();
